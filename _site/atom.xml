<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.7">Jekyll</generator><link href="http://0.0.0.0:4000/atom.xml" rel="self" type="application/atom+xml" /><link href="http://0.0.0.0:4000/" rel="alternate" type="text/html" /><updated>2020-06-01T14:09:54-05:00</updated><id>http://0.0.0.0:4000/atom.xml</id><entry><title type="html">MySQL y los emojis</title><link href="http://0.0.0.0:4000/mysql-emojis.html" rel="alternate" type="text/html" title="MySQL y los emojis" /><published>2020-05-18T00:00:00-05:00</published><updated>2020-05-18T00:00:00-05:00</updated><id>http://0.0.0.0:4000/mysql-emojis</id><content type="html" xml:base="http://0.0.0.0:4000/mysql-emojis.html">&lt;p&gt;Esta es la típica tontería inútil que da problemas, veamos como se implementa y donde puede haber problemas, al grano, vemos todo lo que hace falta para que funcione, y los ejemplos que trataremos están hechos para saber investigar el problema y poder resolverlo:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Debes utilizar el encoding &lt;code class=&quot;highlighter-rouge&quot;&gt;utf8mb4&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;El encoding debe estar configurado en varios sitios; en las tablas a usar, en la conexión de la aplicación y en las variables de entorno. En este punto es donde suele haber problemas.&lt;/li&gt;
  &lt;li&gt;Debes asegurarte de que los datos se guardan y se recuperan bien.&lt;/li&gt;
  &lt;li&gt;Realiza pruebas en un entorno seguro y controlado.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Si ya estas utilizando el encoding &lt;code class=&quot;highlighter-rouge&quot;&gt;utf8&lt;/code&gt; no es problema que implementes &lt;code class=&quot;highlighter-rouge&quot;&gt;utf8mb4&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Vamos a crear primero una tabla como debe ser, luego modificar una tabla existente y luego agregamos varios registros de ejemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-SQL&quot;&gt;DROP TABLE IF EXISTS foo;
CREATE TABLE IF NOT EXISTS `foo` (
  `id` bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT,
  `text` varchar(2000) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

INSERT INTO foo (`text`) VALUES (&quot;test case&quot;);
INSERT INTO foo (`text`) VALUES (&quot;🚌&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Podemos modificar una tabla existente para que use &lt;code class=&quot;highlighter-rouge&quot;&gt;utf8mb4&lt;/code&gt;, en el ejemplo pongo como crear la tabla y luego como modificarla:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-SQL&quot;&gt;DROP TABLE IF EXISTS foo;
CREATE TABLE IF NOT EXISTS `foo` (
  `id` bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT,
  `text` varchar(2000) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

ALTER TABLE foo CONVERT TO CHARACTER SET utf8mb4;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;ADVERTENCIA:&lt;/strong&gt; Cuidado con el tamano de la tabla a la hora de modificarla, y el encoding diferente al &lt;code class=&quot;highlighter-rouge&quot;&gt;utf8&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Ahora insertamos varios registros y vemos que pasa:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-SQL&quot;&gt;INSERT INTO foo (`text`) VALUES (&quot;test case&quot;);
INSERT INTO foo (`text`) VALUES (&quot;🚌&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Posiblemente se te genere la siguiente salida, donde el primer registro se agrego perfectamente pero en el segundo registro tienes &lt;strong&gt;2 warnings&lt;/strong&gt;, hay que prestar mucho a esa información que suele ser ignorada.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mysql&amp;gt; INSERT INTO foo (`text`) VALUES (&quot;test case&quot;);
Query OK, 1 row affected (0.01 sec)

mysql&amp;gt; INSERT INTO foo (`text`) VALUES (&quot;🚌&quot;);
Query OK, 1 row affected, 2 warnings (0.01 sec)

mysql&amp;gt; SHOW WARNINGS;
+---------+------+-----------------------------------------------------------------------+
| Level   | Code | Message                                                               |
+---------+------+-----------------------------------------------------------------------+
| Warning | 1300 | Invalid utf8 character string: 'F09F9A'                               |
| Warning | 1366 | Incorrect string value: '\xF0\x9F\x9A\x8C' for column 'text' at row 1 |
+---------+------+-----------------------------------------------------------------------+
2 rows in set (0.00 sec)

mysql&amp;gt; SELECT * FROM foo;
+----+-----------+
| id | text      |
+----+-----------+
|  1 | test case |
|  2 | ????      |
+----+-----------+
2 rows in set (0.00 sec)

mysql&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Como puedes ver, usando el comando &lt;code class=&quot;highlighter-rouge&quot;&gt;SHOW WARNINGS&lt;/code&gt; te lista los mensajes, aquí podemos observar no hay compatibilidad con el emoji y sobre escribe el valor de dicho emoji para hacerlo compatible al &lt;code class=&quot;highlighter-rouge&quot;&gt;CHARACTER_SET&lt;/code&gt; actual, también puedes observar que hiciste &lt;code class=&quot;highlighter-rouge&quot;&gt;SELECT&lt;/code&gt; del contenido de la tabla y no está el emoji sino una serie de símbolos,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-SQL&quot;&gt;SELECT id, `text`, HEX(`text`) FROM foo WHERE id = 2;
SELECT HEX(&quot;🚌&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Es cierto que se creo antes la tabla con el soporte a &lt;code class=&quot;highlighter-rouge&quot;&gt;utf8mb4&lt;/code&gt; y aún así esta dando problemas, debemos revisar las variables del servidor relacionadas a este tipo de configuración, posiblemente nos falta algo, hagamos la siguiente consulta para averiguarlo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-SQL&quot;&gt;SELECT @@collation_connection,
       @@collation_database,
       @@collation_server,
       @@character_set_client,
       @@character_set_connection,
       @@character_set_database,
       @@character_set_filesystem,
       @@character_set_results,
       @@character_set_server,
       @@character_set_system,
       @@init_connect\G
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Por ejemplo no usamos la sentencia &lt;code class=&quot;highlighter-rouge&quot;&gt;SHOW VARIABLES LIKE 'character%';&lt;/code&gt; y su variante porque debes ejecutarla por cada tipo de variables [collation&lt;/td&gt;
      &lt;td&gt;character] o una variable en específico, es cosa tuya. De la query anterior posiblemente obtengamos el siguiente resultado:&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;*************************** 1. row ***************************
    @@collation_connection: utf8_general_ci
      @@collation_database: latin1_swedish_ci
        @@collation_server: latin1_swedish_ci
    @@character_set_client: utf8
@@character_set_connection: utf8
  @@character_set_database: latin1
@@character_set_filesystem: binary
   @@character_set_results: utf8
    @@character_set_server: latin1
    @@character_set_system: utf8
            @@init_connect:
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Ya podemos ver que tenemos un desorden en las variables, toda una ensalada de opciones, deberíamos unificar el mayor número de opciones. Como hemos dicho, necesitamos tener definida la opción &lt;code class=&quot;highlighter-rouge&quot;&gt;utf8mb4&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Tampoco está demás verificar el collation de la tabla:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-SQL&quot;&gt;SELECT table_collation FROM information_schema.tables WHERE table_schema = 'demo' AND table_name = 'foo';
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Como la creamos nosotros desde el principio, y no te olvidaste de hacer el ALTER, seguramente todo está bien, ahora cambiamos la configuración en la sesión actual de la conexión y actualizamos el registro problemático y verificamos que todo está bien:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-SQL&quot;&gt;SET character_set_client = 'utf8mb4'; SET character_set_connection = 'utf8mb4'; SET character_set_results = 'utf8mb4';
UPDATE demo.foo SET `text` = &quot;🚌&quot; WHERE id = 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Es muy importante que en la conexión de nuestro código que usa la base de datos y dicha tabla se le especifique el &lt;code class=&quot;highlighter-rouge&quot;&gt;CHARACTER_SET&lt;/code&gt; para evitar algún problema, este es un ejemplo en python, consulta tu lenguaje y/o framework.&lt;/p&gt;

&lt;script src=&quot;https://emgithub.com/embed.js?target=https%3A%2F%2Fgithub.com%2Fswapbyt3s%2FMyScripts%2Fblob%2Fmaster%2Fexamples%2Fpython%2Fmysql_emoji.py&amp;amp;style=github&amp;amp;showBorder=on&amp;amp;showLineNumbers=on&amp;amp;showFileMeta=on&quot;&gt;&lt;/script&gt;

&lt;p&gt;Fin.&lt;/p&gt;</content><author><name></name></author><category term="mysql" /><category term="collation" /><summary type="html">Esta es la típica tontería inútil que da problemas, veamos como se implementa y donde puede haber problemas, al grano, vemos todo lo que hace falta para que funcione, y los ejemplos que trataremos están hechos para saber investigar el problema y poder resolverlo:</summary></entry><entry><title type="html">MySQL y los Timeouts</title><link href="http://0.0.0.0:4000/mysql-timeouts.html" rel="alternate" type="text/html" title="MySQL y los Timeouts" /><published>2020-05-16T00:00:00-05:00</published><updated>2020-05-16T00:00:00-05:00</updated><id>http://0.0.0.0:4000/mysql-timeouts</id><content type="html" xml:base="http://0.0.0.0:4000/mysql-timeouts.html">Suele pasar mucho con los de **business intelligence, data science y sus variantes**, puede deberse a varias razones, vamos al grano:

- Si te conectas desde tu casa u oficina al cloud para traer información, la realidad es que la intermitencia no la puedes controlar, puede ser por el ISP, o por la VPN o quien sabe que.
- Volúmenes de datos muy grandes. Haz que la query retorne volúmenes más pequeños, en vez de todo el mes, que sea por día.
- Tiempos de respuesta muy elevados, te falta un indice ó por la misma razón debes hacer lo anterior, traerte trozos pequeños y razonables de datos, o algún bloqueo.
- Estas tratando con una ddbb transaccional por lo que los tiempos están ajustados para ello y más si es una aplicación web que no debe tardar más de 30s en responder por ejemplo porque sino el hilo de ejecución del web server muere.

Se podría configurar el cliente o tu script o programa para que cambie esos tiempos a la hora de establecer la conexión y recibir los datos, pero antes debes saber que hay definido y luego ver que ajustas. Haz la siguiente query:

```sql
SELECT @@net_write_timeout, @@wait_timeout;
```
Cada vez que el cliente se conecta hereda una serie de configuraciones globales, pero también puedes ajustar algunas de ellas en tu sesión, como lo vamos hacer ahora. Cada una de esas variables significa algo:

- **net_write_timeout:** Indica la cantidad de segundos en que el servidor escribe al cliente y debe esperar para abortar la conexión.
- **wait_timeout:** Indica la cantidad de segundos sin actividad que debe esperar para abortar la conexión.
Como ajustas wait_timeout:

```sql
SET SESSION wait_timeout = 300;
SELECT * FROM book WHERE year BETWEEN 2000 AND 2001;
```

Esto es bastante de probar y ajustar hasta conseguir los valores adecuados, recuerda que la cache y el buffer pool también pueden jugartela con los tiempos de respuesta.

Las variables las puedes cambiar en su conexión / session de MySQL sin perjudicar el resto del comportamiento del cluster.

Adicionalmente, recomiendo hacer lecturas de datos sin generar bloqueos que pueda comprometer la replicación o una transacción entre otras cosas, para ello debes definir el nivel de aislamiento transaccional:

```sql
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED ;
SELECT * FROM book WHERE year BETWEEN 2000 AND 2001;
```

Fin.</content><author><name></name></author><category term="mysql" /><category term="timeout" /><summary type="html">Suele pasar mucho con los de business intelligence, data science y sus variantes, puede deberse a varias razones, vamos al grano:</summary></entry><entry><title type="html">El teorema CAP</title><link href="http://0.0.0.0:4000/teorema-cap.html" rel="alternate" type="text/html" title="El teorema CAP" /><published>2016-06-12T00:00:00-05:00</published><updated>2016-06-12T00:00:00-05:00</updated><id>http://0.0.0.0:4000/teorema-cap</id><content type="html" xml:base="http://0.0.0.0:4000/teorema-cap.html">Éste post me parece muy importante para poder entender como funcionan y hacer grandes sistemas pensados para escalar, sea por tráfico, por multi-sitio, multi-país, y más… todos estos sistemas distribuidos presentan la misma particularidad, y en el año 2000 un señor llamado [Eric Brewer](https://en.wikipedia.org/wiki/CAP_theorem), pudo definir tres importantes propiedades y desarrollo un teorema. El se dio cuenta que mientras más aplicaciones basadas en la WEB existan, menos debemos preocuparnos por la consistencia de los datos, si queremos alta disponibilidad de nuestras aplicaciones entonces no podemos garantizar la consistencia de los datos.

El teorema CAP, también llamado formalmente Teorema de Brewer, dice que un **sistema de datos distribuido pude asegurar dos de estas tres propiedades: Consistencia, Disponibilidad y Tolerancia al particionado.** Bien, que significa cada una:

- La consistencia (Consistency), Todos los nodos deben ver los mismos datos al mismo tiempo, esto quiere decir que; cualquier cambios en los datos se debe aplicar en todos los nodos, y cuando se recupere el dato tiene que ser el mismo en todos los nodos. Esto se le llama consistencia atómica, y se consigue replicando la información en todos los nodos.
- La disponibilidad (Availability), Cada petición en un nodo debe recibir y garantizar una confirmación si ha sido resuelta satisfactoriamente. En pocas palabras, se debe leer y escribir en todos los nodos.
- La tolerancia al particionado (Partition Tolerance), El sistema debe funcionar a pesar de que haya sido dividido por un fallo de comunicación, garantizando la disponibilidad a pesar que un nodo se separe del grupo sin importar la causa.

![El teorema CAP]({{ &quot;/assets/CAPTheorem.png&quot; | absolute_url }})

El teorema solo nos puede garantizar las siguientes combinaciones:

- CP (Consistency &amp; Partition): El sistema aplicara los cambios de forma forma consistente y aunque se pierda la comunicación entre nodos ocacionando el particionado, no se asegura que haya disponibilidad.
- AP (Availability &amp; Partition): El sistema siempre estará disponible a las peticiones aunque se pierda la comunicación entre los nodos ocacionando el particionado, y en consecuencia por la perdida de comunicación existirá inconsistencia porque no todos los nodos serán iguales.
- CA (Consistency &amp; Availability): El sistema siempre estará disponible respondiendo las peticiones y los datos procesados serán consistentes. En este caso no se puede permitir el particionado.

La correcta decisión de que combinación necesitamos depende de nuestras necesidades de negocio. Nunca olvide que lo más importante en una base de datos relacional es la Consistencia. Conociendo el teorema CAP, nos puede ayudar aún más para saber que Sistemas de Base de Datos debemos escoger, si un SQL o un NoSQL. Si queremos profundizar más en el tema, recomiendo [este post](http://www.julianbrowne.com/article/brewers-cap-theorem).</content><author><name></name></author><category term="database" /><summary type="html">Éste post me parece muy importante para poder entender como funcionan y hacer grandes sistemas pensados para escalar, sea por tráfico, por multi-sitio, multi-país, y más… todos estos sistemas distribuidos presentan la misma particularidad, y en el año 2000 un señor llamado Eric Brewer, pudo definir tres importantes propiedades y desarrollo un teorema. El se dio cuenta que mientras más aplicaciones basadas en la WEB existan, menos debemos preocuparnos por la consistencia de los datos, si queremos alta disponibilidad de nuestras aplicaciones entonces no podemos garantizar la consistencia de los datos.</summary></entry><entry><title type="html">Actualizar datos de una tabla sin bloquearla desde un archivo</title><link href="http://0.0.0.0:4000/actualizar-bloquearla.html" rel="alternate" type="text/html" title="Actualizar datos de una tabla sin bloquearla desde un archivo" /><published>2016-04-11T00:00:00-05:00</published><updated>2016-04-11T00:00:00-05:00</updated><id>http://0.0.0.0:4000/actualizar-bloquearla</id><content type="html" xml:base="http://0.0.0.0:4000/actualizar-bloquearla.html">Hay muchas formas de hacerlo, para variar quise buscar una alternativa rápida y eficaz para evitar escribir un nuevo script, y se me ocurrió usar los comandos de linux, la verdad que resulto muy bien, aquí les dejo un ejemplo:

```bash
cat tokens.csv \
| \
awk -F ',' '{ print &quot;UPDATE users SET token = \&quot;&quot; $2 &quot;\&quot; WHERE token IS NULL AND email = \&quot;&quot; $1 &quot;\&quot;;&quot;; system(&quot;sleep 0.1&quot;);}' \
| \
mysql --login-path=foo \
      --safe-updates \
      --batch \
      --silent \
      --database=foo`
```

Explico un poco, básicamente se lee el archivo con cat, luego se crea la sentencia UPDATE usando el awk, por cada update hacemos una pausa de 100 milisegundo para no saturar, y se lo mandamos al cliente de MySQL.

De vez en cuando nos toca hacer un gran UPDATE sobre una tabla grande que nos puede llevar 10 min. para completar su ejecución, el problema es que si lo hacemos directamente bloqueamos la tabla hasta que termine, eso puede ocasionar varios problemas muy graves a nivel de aplicación, hoy presento una alternativa usando Procedimientos Almacenados.

Básicamente consiste en tener una sentencia que hace UPDATE a cada 1000 rows, se ejecuta dicha query N veces hasta llegar a 0 rows actualizados, en cada interacción hacemos una pequeña pausa de 2 segundos para dejar que pasen las transacciones que están esperando usar dicho recurso.

```SQL
DROP PROCEDURE IF EXISTS sp_users_update;

DELIMITER |
CREATE PROCEDURE sp_users_update()
  BEGIN
    SET @row_count = 0;

    REPEAT
      -- Query to update:
      UPDATE LOW_PRIORITY users SET username = CONCAT('DELETED_', username)
      WHERE deleted_at IS NOT NULL
      AND username NOT LIKE 'DELETED_%'
      LIMIT 1000;

      -- Save row counts for update:
      SET @row_count = (SELECT ROW_COUNT());

      -- Sleep for not blocking table:
      SELECT SLEEP(2);
    UNTIL @row_count = 0 END REPEAT;
  END;
|
DELIMITER ;

CALL sp_users_update();

DROP PROCEDURE IF EXISTS sp_users_update;
```

La verdad que es una alternativa rápida a comparación de un script, es cierto que el proceso de buscar con LIKE es algo costoso para la CPU si son muchos rows, de echo pude observar un pico durante la actualización, nada grave por ser una situación controlada y probada en otros entornos.</content><author><name></name></author><category term="mysql" /><category term="update" /><category term="lock" /><summary type="html">Hay muchas formas de hacerlo, para variar quise buscar una alternativa rápida y eficaz para evitar escribir un nuevo script, y se me ocurrió usar los comandos de linux, la verdad que resulto muy bien, aquí les dejo un ejemplo:</summary></entry><entry><title type="html">Monitorizar y resolver problemas de replicación en MySQL</title><link href="http://0.0.0.0:4000/monitorizar-resolver-problemas-replicacion-mysql.html" rel="alternate" type="text/html" title="Monitorizar y resolver problemas de replicación en MySQL" /><published>2016-03-05T00:00:00-06:00</published><updated>2016-03-05T00:00:00-06:00</updated><id>http://0.0.0.0:4000/monitorizar-resolver-problemas-replicacion-mysql</id><content type="html" xml:base="http://0.0.0.0:4000/monitorizar-resolver-problemas-replicacion-mysql.html">La replicación de datos con slaves es algo muy fácil de configurar y aporta muchos beneficios, pero aveces trae sus grandes problemas si no tenemos en cuenta algunos aspectos de configuración, hardware y red entre otras cosas, vamos a comentar un buen grupo de ellos y ayudarte a saber donde puede estar el problema, se que es muy largo el POST, hay mucho que cubrir, pero tratare de dar la idea.

## Ventajas de usar Slaves

* Divide las escrituras en un master y lecturas en los slaves para distribuir las cargas de trabajo. Esto no lo hace MySQL de forma transparente, la aplicación debe saber que sentencias van al master y al slave.
* Los Slaves que son los servidores de lectura, se pueden optimizar para hacer minería de datos o procesos de reportes.
* Se puede usar un slave para remplazar el master en caso de algún desastre como una medida de prevención.
* Como respaldo usando el retraso en la replicación para recuperar datos, ver la variable [MASTER_DELAY][1].
* Incluso podemos configurar el MultiMaster de dos nodos, pero esto aveces no funciona bien por como esta programada la aplicación.

Los problemas que surgen por la replicación no son nuevos, podemos clasificarlos en dos grandes grupos; Cuando se interrumpe la replicación por alguna inconsistencia, o un retraso de la replicación a pesar que no esté interrumpida.

Para saber el estado de una replicación ejecute este comando en el slave:

```SQL
SHOW SLAVE STATUS\G
```

Recuerde que el estado de la replicación es individual en cada slave. A partir de aquí, tenemos una serie de variables que nos indica que está pasando y también les explico como resolver cualquiera de estos dos grandes problemas.

### Como identificar una replicación interrumpida:

Este problema se puede presentar por una serie de motivos:

* Inconsistencia de datos entre el Master y el Slave.
* Diferentes configuraciones.
* Diferente hora.
* Problemas de red.
* Bloqueos de tablas o de registros.
* Muchos INSERT, UPDATE o DELETES.

Cuando se ejecuta el comando &quot;SHOW SLAVE STATUS&quot; que mencionamos anteriormente, entre todas las variables que nos muestra, debemos hacerle caso a estas:

* **Slave_IO_Running:** Si es &quot;Yes&quot;, entonces el esclavo está conectado al master.
* **Slave_SQL_Running:** Si es &quot;Yes&quot;, entonces el esclavo está procesando las consultas SQL.
* **Seconds_Behind_Master:** Indica la cantidad de posiciones retrasadas del binlog, si es 0 es que todo está bien.
* **Last_Error:** Si &quot;Slave_SQL_Running&quot; es &quot;No&quot;, entonces muestra la última sentencia SQL que produjo un error y se detiene la replicación.

Para resolver la mayoría de los casos, solo debemos ejecutar estos tres comandos:

```SQL
STOP SLAVE; SET GLOBAL SQL_SLAVE_SKIP_COUNTER=1; START SLAVE;
```

Y volver a ejecutar este comando para verificar que no hayan más errores:

```SQL
SHOW SLAVE STATUS\G
```

Es muy importante saber porque pasó esto y como prevenirlo, el echo de saltar el error y continuar nos crea una inconsistencia de los datos, debemos tomar nota del mensaje de error y resolverlo a mano.

### Como identificar el retraso de la replicación:

Primero debemos entender como funciona y cuales son los indicadores que se pueden encontrar en el estado de la replica. La replicación en MySQL trabaja con dos hilos, IO_THREAD y SQL_THREAD.

* El primer hilo es IO_THREAD, se conecta a un maestro, lee los eventos del binarios del maestro y los va guardando en un log local llamado **relay log** (registro retrasado). Corresponde este hilo con la variable de estado **Slave_IO_Running**.
* El segundo hilo es SQL_THREAD, lee los eventos del relay log almacenado localmente en el esclavo, el cual fue escrito por el hilo IO_THREAD y luego los aplica lo más rápido posible en el slave. Corresponde este hilo con la variable de estado **Slave_SQL_Running**.

Siempre que se presenta un retraso en la replicación, es importante saber cual de los dos hilos se encuentra el problema. Normalmente, los hilos de E/S no causarían enormes retrasos de replicación, ya que una vez que se leen del master, se aplican en el slave. Sin embargo, el retraso se debe a una limitación del hardware o por alguna configuración:

* Si es por el rendimiento de la red, afecta al hilo **IO_THREAD**, aquí debemos evaluar si es un tema de saturación de la red, la [NIC][2] no es suficiente para el trafico, u otro problema de red.
* Si es la velocidad del Hardware del slave al procesar el relay log es afectado por el **SQL_THREAD**. Diferentes configuraciones del servicio, indice de los esquemas, carga de trabajo, hardware lento.

Todo estos detalles hay que verlos con mucho cuidado, se requiere paciencia, pero en líneas generales, aquí se han mencionado todos los puntos que debemos evitar para tener problemas en la replicación Master/Slave.

Les deseo suerte.

[1]: https://dev.mysql.com/doc/refman/5.6/en/replication-delayed.html
[2]: https://es.wikipedia.org/wiki/Tarjeta_de_red</content><author><name></name></author><category term="mysql" /><category term="replica" /><category term="slave" /><summary type="html">La replicación de datos con slaves es algo muy fácil de configurar y aporta muchos beneficios, pero aveces trae sus grandes problemas si no tenemos en cuenta algunos aspectos de configuración, hardware y red entre otras cosas, vamos a comentar un buen grupo de ellos y ayudarte a saber donde puede estar el problema, se que es muy largo el POST, hay mucho que cubrir, pero tratare de dar la idea.</summary></entry><entry><title type="html">Buscar registros huérfanos</title><link href="http://0.0.0.0:4000/registros-huerfanos.html" rel="alternate" type="text/html" title="Buscar registros huérfanos" /><published>2016-02-12T00:00:00-06:00</published><updated>2016-02-12T00:00:00-06:00</updated><id>http://0.0.0.0:4000/registros-huerfanos</id><content type="html" xml:base="http://0.0.0.0:4000/registros-huerfanos.html">Los registros huérfanos son aquellos que se almacenan en un modelo relacional padre-hijo, los registros padres hacen referencia a filas primarias, y los registros hijos hacen referencia a filas secundarías, esto puede pasar por varias razones en una DDBB, básicamente sino existe claves foráneas definidas, o alguien desactivo de forma momentánea el check [foreign_key_checks][1], y para mantener la integridad de los datos debemos de vez en cuando identificar estos registros huérfanos, podríamos eliminarlos o asignarlos a un padre de forma provisional. Yo opto más por lo segundo, conservar los datos es nuestra prioridad.

Los registros huérfanos pueden tener un **Foreign Key igual a NULL o tener un ID de un registro primario que no exista**, pero debemos tener bastante cuidado con el NULL, ya que puede hacer referencia a una relación &quot;PUEDE&quot; y no &quot;DEBE&quot;, lo cual eliminamos algo que no debemos.

Hay varias formas de hacer esta consulta, pero solo una es la más apropiada por temas de rendimiento, seguramente la condición que pensamos de primero es **NOT IN**, pues esa no, ni tampoco usar un **LEFT OUTER JOIN**, deberías de usar **NOT EXISTS** que es mucho más eficiente, a continuación muestro los tres ejemplos, el último es el bueno:

**A) Primer ejemplo incorrecto:**

```SQL
SELECT count(*)
FROM payment AS child
WHERE rental_id NOT IN (SELECT rental_id FROM rental);
```

**B) Segundo ejemplo incorrecto:**

```SQL
SELECT count(*)
FROM payment AS child
LEFT OUTER JOIN rental AS parent ON parent.rental_id = child.rental_id
WHERE child.rental_id IS NOT NULL AND parent.rental_id IS NULL;
```

**C) Primer ejemplo correcto:**

```SQL
SELECT count(*)
FROM payment AS child
WHERE rental_id IS NOT NULL
  AND NOT EXISTS (
  SELECT NULL FROM rental AS parent WHERE parent.rental_id = child.rental_id
);
```

Hay algo curioso en el ejemplo A y C, a ver si se dan cuenta? La única pista, es que tiene que ver con los NULL.

Ahora que los hemos identificado, que hacemos con ellos? bueno, la forma correcta sería la siguiente:

* Agregar un registro primario (padre) para agrupar los registros secundarios (hijos) que están huérfanos.
* Hacer un update en el Foreign Key de todos los registros secundarios con el valor correspondiente al registro primario.
* Verificar que todo este bien.

Espero que les haya sido útil.

[1]: http://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_foreign_key_checks</content><author><name></name></author><category term="mysql" /><summary type="html">Los registros huérfanos son aquellos que se almacenan en un modelo relacional padre-hijo, los registros padres hacen referencia a filas primarias, y los registros hijos hacen referencia a filas secundarías, esto puede pasar por varias razones en una DDBB, básicamente sino existe claves foráneas definidas, o alguien desactivo de forma momentánea el check foreign_key_checks, y para mantener la integridad de los datos debemos de vez en cuando identificar estos registros huérfanos, podríamos eliminarlos o asignarlos a un padre de forma provisional. Yo opto más por lo segundo, conservar los datos es nuestra prioridad.</summary></entry><entry><title type="html">Collation, diferencias entre utf8_general_ci y utf8_unicode_ci</title><link href="http://0.0.0.0:4000/collation-diferencias-utf8_general_ci-utf8_unicode_ci.html" rel="alternate" type="text/html" title="Collation, diferencias entre utf8_general_ci y utf8_unicode_ci" /><published>2016-02-08T00:00:00-06:00</published><updated>2016-02-08T00:00:00-06:00</updated><id>http://0.0.0.0:4000/collation-diferencias-utf8_general_ci-utf8_unicode_ci</id><content type="html" xml:base="http://0.0.0.0:4000/collation-diferencias-utf8_general_ci-utf8_unicode_ci.html">Para los que estamos acostumbrados a trabajar en Linux es normal usar el formato de codificación UTF-8, y en mi opinión personal es lo que se debería de usar para todo. En el caso de MySQL se puede definir en una base de datos, tabla y columna el formato de codificación como CHARSET y un sub formato llamado COLLATE. La intención del COLLATION es poder ayudar en la Presición vs Rendimiento con los carácteres especiales.

Para conocer todos los formatos disponibles de codificación y el sub formato por defecto de MySQL, ejecute el siguiente comando:

```SQL
SHOW CHARACTER SET;
```

Como podemos ver en la lista, el COLLATION por defecto de UTF8 es el utf8_general_ci, existe otro llamado utf8_unicode_ci, y entre los dos hay grandes diferencias y al conocerlas entenderemos porque una está por defecto:

## Precisión para ordenar los datos:

* **utf8_unicode_ci:** Se basa en el estándar Unicode para ordenar, y ordena con precisión en una amplia gama de idiomas.
* **utf8_general_ci:** Se acerca mucho para ordenar correctamente con Unicode en muchos idiomas comunes, pero tiene una serie de imprecisiones al ordenar en algunos idiomas, por lo que no es recomendable para la correcta ordenación en todos los idiomas.

## Rendimiento:

* **utf8_general_ci:** Es más rápido en las comparaciones y la ordenación, está puntualmente diseñado para el rendimiento, ignora los detalles según el idioma.
* **utf8_unicode_ci:** Utiliza un algoritmo mucho más complejo para comparar, tiene como objetivo la clasificación correcta de acuerdo en una amplia gama de idiomas. Esto hace que sea más lento para ordenar y comparar un gran número de campos.

## Limitaciones:

* No se puede realizar comparación directa entre valores de diferente COLLATION, puede resolverlo usando el operador BINARY, pero usar esta alternativa baja mucho el rendimiento.

Quedo claro que el formato por defecto utf8_general_ci es el más rápido y el menos impreciso. La definición de estos formatos depende de nuestras necesidades muy particulares.

La siguiente consulta permite listar todas las tablas que no tienen el collation por defecto:

```SQL
SELECT table_schema, table_name, engine, table_collation
FROM INFORMATION_SCHEMA.TABLES
WHERE table_type = 'BASE TABLE'
  AND table_schema NOT IN ('mysql', 'performance_schema')
  AND (engine &lt;&gt; 'InnoDB' OR  table_collation &lt;&gt; 'utf8_general_ci');
```

Si queremos profundizar un poco más sobre el tema, les dejo los siguientes enlases oficiales de MySQL que explican todo estoy muy bien, y hasta tiene unos ejemplos:

* [Character Sets and Collations in General][1]
* [Examples of the Effect of Collation][2]
* [The BINARY Operator][3]

 [1]: https://dev.mysql.com/doc/refman/5.6/en/charset-general.html
 [2]: https://dev.mysql.com/doc/refman/5.6/en/charset-collation-effect.html
 [3]: https://dev.mysql.com/doc/refman/5.6/en/charset-binary-op.html</content><author><name></name></author><category term="mysql" /><category term="collation" /><summary type="html">Para los que estamos acostumbrados a trabajar en Linux es normal usar el formato de codificación UTF-8, y en mi opinión personal es lo que se debería de usar para todo. En el caso de MySQL se puede definir en una base de datos, tabla y columna el formato de codificación como CHARSET y un sub formato llamado COLLATE. La intención del COLLATION es poder ayudar en la Presición vs Rendimiento con los carácteres especiales.</summary></entry><entry><title type="html">Bloqueos en MySQL</title><link href="http://0.0.0.0:4000/bloqueos-optimistas-pesimistas-mysql.html" rel="alternate" type="text/html" title="Bloqueos en MySQL" /><published>2015-11-17T00:00:00-06:00</published><updated>2015-11-17T00:00:00-06:00</updated><id>http://0.0.0.0:4000/bloqueos-optimistas-pesimistas-mysql</id><content type="html" xml:base="http://0.0.0.0:4000/bloqueos-optimistas-pesimistas-mysql.html">El bloqueo es la esencia de cualquier manejador de bases de datos relacional (RDBMS), para el caso de MySQL es importante destacar que el engine **InnoDB** lo gestiona de forma óptima, hasta la fecha no hay otro que lo haga mejor.

No podemos confundir bloqueos con [niveles de aislamiento][1], ya que el bloqueo se hace a nivel de registros usando una instrucción específica, mientras el nivel de aislamiento es el comportamiento por defecto para cualquier otra instrucción normal que manipule los registros.

Los bloqueos existen para poder garantizar el [ACID][2], su correcta implementación permite que halla **concurrencia**, de lo contrario se puede presentar la **contención** y es fatal.

Los bloqueos los podemos dividir en dos grandes grupos; está el bloqueo pesimista y el bloqueo optimista, vamos a entender cada uno:

* **Pesimista:** Es aquel que se apodera del recurso (row/tabla) y no lo libera hasta que se haya modificado. Generalmente se hace con instrucciones propias del RDBMS. Para el caso de MySQL tenemos dos instrucciones; el [SELECT ... FOR UPDATE y el SELECT ... LOCK IN SHARE MODE][3] y no hablar de [LOCK TABLE][4]. Éste tipo de bloqueo produce [Deadlock][5] sin importar la forma como lo controlemos, al final estamos bloqueando un recurso que usa una conexión especifica, tiene un timeout, y otros procesos que esperan por el, esto puede generar una contención, problemas de atomicidad, y muchas más situaciones lamentables.
* **Optimista:** Es la mejor forma de bloquear un recurso fomentando la concurrencia, no existe instrucción SQL que añada ésta funcionalidad, más bien usamos las instrucciones DML existentes, y se basa en la lógica del [MVCC][6]. Consiste en añadir una columna para versionar el registro y evitar que el último estado sea modificado. Por ejemplo: cuando una sesión quiere modificar un registro, ésta lee y hace UPDATE con la última versión conocida de dicho registro, si hay otra transacción que se adelanta para hacer el mismo UPDATE, la versión cambia, y el UPDATE será obsoleto.

Para la mayoría de las aplicaciones WEB, se debe utilizar el bloqueo optimista, como podemos ver, no es más que una implementación de una columna que versiona el registro y la combinación simple de un SELECT y un UPDATE, de esta forma evitamos los [Deadlock][5], la contención, y muchos otros problemas. Los ORM, como por ejemplo Hibernate o ActiveRecord tienen ésta funcionalidad implementada, nos quitan una capa más de detalle y no será necesario modificar el modelo y las consultas.

 [1]: https://www.swapbytes.com/niveles-aislamiento-base-de-datos/
 [2]: https://en.wikipedia.org/wiki/ACID
 [3]: http://dev.mysql.com/doc/refman/5.7/en/innodb-locking-reads.html
 [4]: http://dev.mysql.com/doc/refman/5.7/en/lock-tables.html
 [5]: https://en.wikipedia.org/wiki/Deadlock
 [6]: https://es.wikipedia.org/wiki/Multiversion_concurrency_control</content><author><name></name></author><category term="mysql" /><summary type="html">El bloqueo es la esencia de cualquier manejador de bases de datos relacional (RDBMS), para el caso de MySQL es importante destacar que el engine InnoDB lo gestiona de forma óptima, hasta la fecha no hay otro que lo haga mejor.</summary></entry><entry><title type="html">Seguridad en MySQL con mysql_config_editor</title><link href="http://0.0.0.0:4000/mysql-config-editor.html" rel="alternate" type="text/html" title="Seguridad en MySQL con mysql_config_editor" /><published>2015-07-23T00:00:00-05:00</published><updated>2015-07-23T00:00:00-05:00</updated><id>http://0.0.0.0:4000/mysql-config-editor</id><content type="html" xml:base="http://0.0.0.0:4000/mysql-config-editor.html">En la versión 5.6.6 se incluyo una nueva herramienta llamada [mysql_config_editor][1], la cual permite almacenar las credenciales de autenticación de una forma segura y otros datos básicos en un archivo llamado '.mylogin.cnf' en el directorio home del usuario, luego estas credenciales pueden ser recuperadas para conectarse al servidor de MySQL deseado.

A simple vista no parece, pero es muy importante que considere que **el archivo '.mylogin.cnf' no está cifrado**, y no es completamente seguro, pero añade una capa más de seguridad ocultando los datos sensibles por la línea de comandos. Por ejemplo, ocultamos la contraseña en el; historial, alias, logs, scripts, etc... donde puede ser visible de muchas formas.

En el siguiente ejemplo se muestra la forma tradicional de conectarse a una base de datos usando todos los parámetros básicos; host, usuario y clave:

```bash
$ mysql -h production.db.empresa.org -u root -pmypass
```

Usando la nueva herramienta nos conectamos de la siguiente forma:

```bash
$ mysql --login-path=production
```

Asumiendo que ya hemos creado la configuración 'production' usando la herramienta, podemos ver que estamos especificando con el parámetro '--login-path' para que use la configuración 'production' y así conectarse al servidor.

Para poder agregar una configuración, debemos ejecutar el siguiente comando:

```bash
mysql_config_editor set --login-path=production --host=production.db.empresa.org --user=root -p
```

La contraseña no se puede pasar por línea de comando, debemos escribirla para mantenerla un poco más segura. Si queremos conocer todas las configuraciones disponibles, solo debemos ejecutar el siguiente comando:

```bash
mysql_config_editor print --all
```

Si queremos aprender más sobre esta herramienta, recomiendo [visitar su página web][1].

[1]: http://dev.mysql.com/doc/refman/5.6/en/mysql-config-editor.html</content><author><name></name></author><category term="mysql" /><category term="cli" /><summary type="html">En la versión 5.6.6 se incluyo una nueva herramienta llamada mysql_config_editor, la cual permite almacenar las credenciales de autenticación de una forma segura y otros datos básicos en un archivo llamado ‘.mylogin.cnf’ en el directorio home del usuario, luego estas credenciales pueden ser recuperadas para conectarse al servidor de MySQL deseado.</summary></entry><entry><title type="html">Origen de la palabra NoSQL</title><link href="http://0.0.0.0:4000/origen-nosql.html" rel="alternate" type="text/html" title="Origen de la palabra NoSQL" /><published>2015-06-08T00:00:00-05:00</published><updated>2015-06-08T00:00:00-05:00</updated><id>http://0.0.0.0:4000/origen-nosql</id><content type="html" xml:base="http://0.0.0.0:4000/origen-nosql.html">Es curioso como se desencadena toda una revolución por un simple hashtag. Aquí les dejo una breve historia de su verdadero origen:

Johan Oskarsson organizó un evento en Junio de 2009 en San Francisco, la intención era discutir las nuevas tecnologías en el mundo IT sobre el almacenamiento y procesamiento de datos. La principal razón del evento fueron los nuevos productos como BigTable y Dynamo. Para el evento era necesario encontrar una palabra clave para ser usada en un hashtag de Twitter, término siendo **&quot;[NoSQL](http://es.wikipedia.org/wiki/NoSQL)&quot;** y fue sugerido por Eric Evans de RackSpace. El término fue planeado para ser utilizado sólo para ésta reunión y no tenía un significado profundo. Pero resultó que se extendió por la red de forma viral y se convirtió en el nombre de facto de una tendencia de las bases de datos no relacionales y distribuidas.

El término &quot;NoSQL&quot; tiene un origen absolutamente natural y éste no está avalado por una institución científica. Se considera que el término esta lejos de su completa definición, hay autores como Pramod J. Sadalage y Martin Fowler que trataron de agrupar y organizar todo el conocimiento sobre el mundo NoSQL en el libro &quot;[NoSQL destilada](http://www.amazon.com/NoSQL-Distilled-Emerging-Polyglot-Persistence/dp/0321826620)&quot;.

**Fuentes:**

* [Introduction to NoSQL by Martin Fowler](https://www.youtube.com/watch?v=qI_g07C_Q5I)
* [World of the NoSQL databases](http://leopard.in.ua/2013/11/08/nosql-world/)</content><author><name></name></author><category term="database" /><category term="nosql" /><summary type="html">Es curioso como se desencadena toda una revolución por un simple hashtag. Aquí les dejo una breve historia de su verdadero origen:</summary></entry></feed>